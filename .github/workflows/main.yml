on:
  push:
    paths:
      - '**/*'
  pull_request:
    paths:
      - '**/*'

jobs:
  Build-Databricks-Apps:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v3

    - name: Install Databricks CLI
      run: curl -fsSL https://raw.githubusercontent.com/databricks/setup-cli/main/install.sh | sh

    - name: Get Databricks Access Token using Service Principal
      run: |
        export CLIENT_ID=${{ secrets.DATABRICKS_CLIENT_ID_CICD }}
        export CLIENT_SECRET=${{ secrets.DATABRICKS_CLIENT_SECRET_CICD }}
        export TOKEN_ENDPOINT_URL="${{ secrets.DATABRICKS_HOST }}/oidc/v1/token"
        
        DATABRICKS_TOKEN=$(curl --request POST \
          --url "$TOKEN_ENDPOINT_URL" \
          --user "$CLIENT_ID:$CLIENT_SECRET" \
          --data 'grant_type=client_credentials&scope=all-apis' | jq -r .access_token)
        
        echo "DATABRICKS_TOKEN=$DATABRICKS_TOKEN" >> $GITHUB_ENV

    - name: Create Databricks Directory for apps
      run: |
        RESPONSE=$(curl --request POST \
          --url "${{ secrets.DATABRICKS_HOST }}/api/2.0/workspace/mkdirs" \
          --header "Authorization: Bearer $DATABRICKS_TOKEN" \
          --header "Content-Type: application/json" \
          --data '{"path": "/apps"}')

        echo "response=$RESPONSE" >> $GITHUB_ENV
        echo "$RESPONSE"

    - name: Setup python
      uses: actions/setup-python@v2

    - name: Databricks sync
      env:
        DATABRICKS_HOST: ${{ secrets.DATABRICKS_HOST }}
        DATABRICKS_TOKEN: ${{ env.DATABRICKS_TOKEN }}
      run: |
        echo "Checking out the releases branch"
        databricks -v 
        databricks sync ./apps/ /apps --full 


    
    - name: Create Databricks app if not exists
      env:
        DATABRICKS_HOST: ${{ secrets.DATABRICKS_HOST }}
        DATABRICKS_TOKEN: ${{ env.DATABRICKS_TOKEN }}
      run: |

        for app_dir in $(find apps -mindepth 1 -maxdepth 1 -type d); do
          app_name=$(basename "$app_dir")
          if [[ $app_name == .* ]]; then
            echo "Skipping hidden directory: $app_name"
            continue
          fi
          echo "Processing app: $app_name"

          RESPONSE=$(curl --request POST \
          --url "${{ secrets.DATABRICKS_HOST }}/api/2.0/apps" \
          --header "Authorization: Bearer $DATABRICKS_TOKEN" \
          --header "Content-Type: application/json" \
          --data "{\"name\": \"$app_name\", \"default_source_code_path\": \"/apps/$app_name\"}")
        
          echo "response=$RESPONSE" >> $GITHUB_ENV
          echo "Create app $RESPONSE"

          if echo "$RESPONSE" | grep -q "ALREADY_EXISTS"; then
            echo "App $app_name already exists. Skipping creation."
          else
            # Wait until the app is in the ACTIVE state
            while true; do
              APP_STATUS=$(curl --request GET \
                --url "${{ secrets.DATABRICKS_HOST }}/api/2.0/apps/$app_name" \
                --header "Authorization: Bearer $DATABRICKS_TOKEN" | jq -r .compute_status.state)
              
              if [[ "$APP_STATUS" == "ACTIVE" ]]; then
                echo "App $app_name is ACTIVE"
                break
              fi
              
              echo "Waiting for app $app_name to become ACTIVE. Current state: $APP_STATUS"
              sleep 30
            done
          fi
          #This will make sure that the up will update
          databricks apps deploy $app_name --source-code-path /Workspace/apps/$app_name

        done

    - name: Get app Service principals and add to app group
      env:
        DATABRICKS_HOST: ${{ secrets.DATABRICKS_HOST }}
        DATABRICKS_TOKEN: ${{ env.DATABRICKS_TOKEN }}
      run: |

        # List all apps and extract service_principal_ids
        SERVICE_PRINCIPAL_IDS=$(databricks apps list | jq -r '.[].service_principal_id')

        APPS_GROUP_ID=$(databricks groups list | grep 'apps' | awk '{print $1}')
        # Add each service principal to the 'apps' group
        for SP_ID in $SERVICE_PRINCIPAL_IDS; do
          echo "Adding service principal $SP_ID to group 'apps'"
          RESPONSE=$(curl --request PATCH \
            --url "${{ secrets.DATABRICKS_HOST }}/api/2.0/preview/scim/v2/Groups/$APPS_GROUP_ID" \
            --header "Authorization: Bearer $DATABRICKS_TOKEN" \
            --header "Content-Type: application/json" \
            --data '{
              "schemas": [
                "urn:ietf:params:scim:api:messages:2.0:PatchOp"
              ],
              "Operations": [
                {
                  "op": "add",
                  "path": "members",
                  "value": [
                    {
                      "value": "'"$SP_ID"'"
                    }
                  ]
                }
              ]
            }')

          echo "response=$RESPONSE" >> $GITHUB_ENV
          echo "$RESPONSE"
        done